// Mocks generated by Mockito 5.2.0 from annotations
// in game_of_flutter/test/test_helper/mocks/blocs/blocs_mocks.dart.
// Do not manually edit this file.

import 'dart:async' as _i7;

import 'package:flutter_bloc/flutter_bloc.dart' as _i8;
import 'package:game_of_flutter/configs/configs.dart' as _i3;
import 'package:game_of_flutter/features/house_details/blocs/character_bloc/character_bloc.dart'
    as _i6;
import 'package:game_of_flutter/features/house_list/blocs/house_list/house_list_bloc.dart'
    as _i4;
import 'package:game_of_flutter/infrastructure/services/character_service.dart'
    as _i5;
import 'package:game_of_flutter/infrastructure/services/house_service.dart'
    as _i2;
import 'package:mockito/mockito.dart' as _i1;

// ignore_for_file: type=lint
// ignore_for_file: avoid_redundant_argument_values
// ignore_for_file: avoid_setters_without_getters
// ignore_for_file: comment_references
// ignore_for_file: implementation_imports
// ignore_for_file: invalid_use_of_visible_for_testing_member
// ignore_for_file: prefer_const_constructors
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: camel_case_types

class _FakeHouseService_0 extends _i1.Fake implements _i2.HouseService {}

class _FakeConfigs_1 extends _i1.Fake implements _i3.Configs {}

class _FakeHouseListState_2 extends _i1.Fake implements _i4.HouseListState {}

class _FakeCharacterService_3 extends _i1.Fake implements _i5.CharacterService {
}

class _FakeCharacterState_4 extends _i1.Fake implements _i6.CharacterState {}

/// A class which mocks [HouseListBloc].
///
/// See the documentation for Mockito's code generation for more information.
class MockHouseListBloc extends _i1.Mock implements _i4.HouseListBloc {
  MockHouseListBloc() {
    _i1.throwOnMissingStub(this);
  }

  @override
  _i2.HouseService get houseService =>
      (super.noSuchMethod(Invocation.getter(#houseService),
          returnValue: _FakeHouseService_0()) as _i2.HouseService);
  @override
  _i3.Configs get configs => (super.noSuchMethod(Invocation.getter(#configs),
      returnValue: _FakeConfigs_1()) as _i3.Configs);
  @override
  _i4.HouseListState get state => (super.noSuchMethod(Invocation.getter(#state),
      returnValue: _FakeHouseListState_2()) as _i4.HouseListState);
  @override
  _i7.Stream<_i4.HouseListState> get stream =>
      (super.noSuchMethod(Invocation.getter(#stream),
              returnValue: Stream<_i4.HouseListState>.empty())
          as _i7.Stream<_i4.HouseListState>);
  @override
  bool get isClosed =>
      (super.noSuchMethod(Invocation.getter(#isClosed), returnValue: false)
          as bool);
  @override
  void add(_i4.HouseListEvent? event) =>
      super.noSuchMethod(Invocation.method(#add, [event]),
          returnValueForMissingStub: null);
  @override
  void onEvent(_i4.HouseListEvent? event) =>
      super.noSuchMethod(Invocation.method(#onEvent, [event]),
          returnValueForMissingStub: null);
  @override
  void emit(_i4.HouseListState? state) =>
      super.noSuchMethod(Invocation.method(#emit, [state]),
          returnValueForMissingStub: null);
  @override
  void on<E extends _i4.HouseListEvent>(
          _i8.EventHandler<E, _i4.HouseListState>? handler,
          {_i8.EventTransformer<E>? transformer}) =>
      super.noSuchMethod(
          Invocation.method(#on, [handler], {#transformer: transformer}),
          returnValueForMissingStub: null);
  @override
  void onTransition(
          _i8.Transition<_i4.HouseListEvent, _i4.HouseListState>? transition) =>
      super.noSuchMethod(Invocation.method(#onTransition, [transition]),
          returnValueForMissingStub: null);
  @override
  _i7.Future<void> close() => (super.noSuchMethod(Invocation.method(#close, []),
      returnValue: Future<void>.value(),
      returnValueForMissingStub: Future<void>.value()) as _i7.Future<void>);
  @override
  void onChange(_i8.Change<_i4.HouseListState>? change) =>
      super.noSuchMethod(Invocation.method(#onChange, [change]),
          returnValueForMissingStub: null);
  @override
  void addError(Object? error, [StackTrace? stackTrace]) =>
      super.noSuchMethod(Invocation.method(#addError, [error, stackTrace]),
          returnValueForMissingStub: null);
  @override
  void onError(Object? error, StackTrace? stackTrace) =>
      super.noSuchMethod(Invocation.method(#onError, [error, stackTrace]),
          returnValueForMissingStub: null);
}

/// A class which mocks [CharacterBloc].
///
/// See the documentation for Mockito's code generation for more information.
class MockCharacterBloc extends _i1.Mock implements _i6.CharacterBloc {
  MockCharacterBloc() {
    _i1.throwOnMissingStub(this);
  }

  @override
  _i5.CharacterService get characterService =>
      (super.noSuchMethod(Invocation.getter(#characterService),
          returnValue: _FakeCharacterService_3()) as _i5.CharacterService);
  @override
  _i3.Configs get configs => (super.noSuchMethod(Invocation.getter(#configs),
      returnValue: _FakeConfigs_1()) as _i3.Configs);
  @override
  _i6.CharacterState get state => (super.noSuchMethod(Invocation.getter(#state),
      returnValue: _FakeCharacterState_4()) as _i6.CharacterState);
  @override
  _i7.Stream<_i6.CharacterState> get stream =>
      (super.noSuchMethod(Invocation.getter(#stream),
              returnValue: Stream<_i6.CharacterState>.empty())
          as _i7.Stream<_i6.CharacterState>);
  @override
  bool get isClosed =>
      (super.noSuchMethod(Invocation.getter(#isClosed), returnValue: false)
          as bool);
  @override
  void add(_i6.CharacterEvent? event) =>
      super.noSuchMethod(Invocation.method(#add, [event]),
          returnValueForMissingStub: null);
  @override
  void onEvent(_i6.CharacterEvent? event) =>
      super.noSuchMethod(Invocation.method(#onEvent, [event]),
          returnValueForMissingStub: null);
  @override
  void emit(_i6.CharacterState? state) =>
      super.noSuchMethod(Invocation.method(#emit, [state]),
          returnValueForMissingStub: null);
  @override
  void on<E extends _i6.CharacterEvent>(
          _i8.EventHandler<E, _i6.CharacterState>? handler,
          {_i8.EventTransformer<E>? transformer}) =>
      super.noSuchMethod(
          Invocation.method(#on, [handler], {#transformer: transformer}),
          returnValueForMissingStub: null);
  @override
  void onTransition(
          _i8.Transition<_i6.CharacterEvent, _i6.CharacterState>? transition) =>
      super.noSuchMethod(Invocation.method(#onTransition, [transition]),
          returnValueForMissingStub: null);
  @override
  _i7.Future<void> close() => (super.noSuchMethod(Invocation.method(#close, []),
      returnValue: Future<void>.value(),
      returnValueForMissingStub: Future<void>.value()) as _i7.Future<void>);
  @override
  void onChange(_i8.Change<_i6.CharacterState>? change) =>
      super.noSuchMethod(Invocation.method(#onChange, [change]),
          returnValueForMissingStub: null);
  @override
  void addError(Object? error, [StackTrace? stackTrace]) =>
      super.noSuchMethod(Invocation.method(#addError, [error, stackTrace]),
          returnValueForMissingStub: null);
  @override
  void onError(Object? error, StackTrace? stackTrace) =>
      super.noSuchMethod(Invocation.method(#onError, [error, stackTrace]),
          returnValueForMissingStub: null);
}
